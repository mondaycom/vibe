import{j as e}from"./jsx-runtime-lwGtIXvq.js";import{useMDXComponents as c}from"./index-BfNsOeqz.js";import{M as l,C as m}from"./index-DLtN7nEL.js";import{U as d,O as p}from"./useActiveDescendantListFocus.stories-Bp8u8BAh.js";import{e as s,a as i}from"./unstyled-list-item-N6f59uEf.js";import{e as r,d as o}from"./function-arguments-Cjbh7Tou.js";import"./index-CTZeEbLr.js";import"./_commonjsHelpers-BosuxZz1.js";import"./iframe-N7aUMKhN.js";import"./index-p5jVhbL8.js";import"./index-BrqHMYbN.js";import"./index-BedKbVpA.js";import"./index-DrFu-skq.js";import"./index-BpvXyOxN.js";import"./interactions-utils-xQn6HIjI.js";import"./index-i7od9_os.js";import"./isObjectLike-CC7ldUSa.js";import"./lz-string-C2WXLmjK.js";import"./test-utils-C6NKoCNh.js";import"./constants-BFnbiwiw.js";import"./uniq-CKVatRnS.js";import"./index-BRKM0OPm.js";import"./useMergeRef-DmpwoaL5.js";import"./index-DtzvftkN.js";import"./index-gB5zY9qh.js";import"./index-CkU0kzyk.js";import"./ssr-utils-Do6V6AqB.js";import"./index-BxdhJjph.js";import"./useIsomorphicLayoutEffect-BBiFUoiz.js";import"./index-BlWfPOxY.js";import"./Search-L_2uKDX2.js";import"./useMergeRef-Do2VYePL.js";import"./test-ids-utils-DBF55-X4.js";import"./index-BHzG1aTI.js";import"./noop-DX6rZLP_.js";import"./debounce-D3NSP8gs.js";import"./CloseSmall-DUYWL2FE.js";import"./_tslib-Ct4JumdA.js";import"./BaseInput-BvzZFTTo.js";import"./typesciptCssModulesHelper-Ji7rRrZn.js";import"./Search-ClaS4_rs.js";import"./IconButton-Cr7FHTpg.js";import"./Button-DRHbYbZf.js";import"./withStaticProps-BEcHOprC.js";import"./Loader-BabV-h63.js";import"./function-utils-BT-tMqNc.js";import"./Icon-CpEYCgaz.js";import"./useEventListener-CkU0kzyk.js";import"./keyCodes-BtXLi1ea.js";import"./Tooltip-WZdDHKve.js";import"./DialogConstants-C6vctR8T.js";import"./Flex-DIp2zxrn.js";import"./Clickable-DHJc0oio.js";import"./useClickableProps-f6_q31tC.js";import"./index-Dedp4W2d.js";import"./CSSTransition-CWtXmFMf.js";import"./extends-B6xKY8K9.js";import"./AddSmall-DFewX5rK.js";function a(n){const t={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...c(),...n.components};return e.jsxs(e.Fragment,{children:[e.jsx(l,{of:d}),`
`,e.jsx(t.h1,{id:"useactivedescendantlistfocus",children:"useActiveDescendantListFocus"}),`
`,e.jsxs("p",{children:[e.jsx("b",{children:"Using this hook for not its intended purpose will hurt your component accessibility."}),e.jsx("br",{})]}),`
`,e.jsx(t.h3,{id:"import",children:"Import"}),`
`,e.jsx(t.pre,{children:e.jsx(t.code,{className:"language-js",children:`import { useActiveDescendantListFocus } from "@vibe/core";
`})}),`
`,e.jsxs(s,{children:[e.jsx(i,{children:e.jsx(t.p,{children:`Please use this hook only if your component role is one of the following: "composite" widget, "combobox", "textbox",
"group", or "application".`})}),e.jsx(i,{children:e.jsx(t.p,{children:`This hook is part of a group of hooks we implement for you to ease the development of accessible components in the
context of managing focus and keyboard navigation.`})}),e.jsx(i,{children:e.jsx(t.p,{children:`Use this hook only when you want the browser's natural focus to be on a specific element (usually text input or
search) when at the same time, the user will see a visual focus on one of the items in the list depending on the use
of the arrow keyboard buttons. Meanwhile, the user can navigate between items and select one of them by using the
keyboard. but the focus on the list's item is always only visual (the real focus always be on a specific element, as
explained before.)`})})]}),`
`,e.jsx(m,{of:p}),`
`,e.jsx(t.h2,{id:"arguments",children:"Arguments"}),`
`,e.jsx(r,{children:e.jsxs(o,{name:"options",type:"Object",children:[e.jsx(o,{name:"focusedElementRef",type:"MutableRefObject<HTMLElement>",description:"The reference for the component that listens to keyboard",required:!0}),e.jsx(o,{name:"itemsIds",type:"string[]",description:"Array of elements ids",required:!0}),e.jsx(o,{name:"isItemSelectable",type:"(index: number) => boolean",description:"If user can select index item",required:!0}),e.jsx(o,{name:"onItemClick",type:"(event: React.KeyboardEvent | React.MouseEvent, index: number) => void",description:"Callback on item click",required:!0}),e.jsx(o,{name:"defaultVisualFocusFirstIndex",type:"boolean",default:"false",description:"Default value of index of the first element, which will get visual focus."}),e.jsx(o,{name:"focusedElementRole",type:"Role",description:"Possible values: useActiveDescendantListFocus.roles.",default:"useActiveDescendantListFocus.roles.GROUP"}),e.jsx(o,{name:"isHorizontalList",type:"boolean",description:"",default:"false"}),e.jsx(o,{name:"isIgnoreSpaceAsItemSelection",type:"boolean",description:"",default:"false"}),e.jsx(o,{name:"useDocumentEventListeners",type:"boolean",description:"",default:"false"}),e.jsx(o,{name:"ignoreDocumentFallback",type:"boolean",description:"",default:"false"})]})}),`
`,e.jsx(t.h2,{id:"returns",children:"Returns"}),`
`,e.jsx(r,{children:e.jsxs(o,{name:"result",type:"Object",children:[e.jsx(o,{name:"visualFocusItemIndex",type:"number",description:"The index of the currently visually focused item element."}),e.jsx(o,{name:"visualFocusItemId",type:"number",description:"The id of the currently visually focused item element."}),e.jsx(o,{name:"createOnItemClickCallback",type:"(itemId) => onItemClickCallback(event, itemId)",description:e.jsxs(e.Fragment,{children:["Higher order function which creates and returns a onclick callback function for item element according to the item id which received as parameter. ",e.jsx(t.br,{}),"If you prefer to create the item's on click callback by yourself, you can use the onItemClickCallback field in this hook return value."]})}),e.jsx(o,{name:"onItemClickCallback",type:"(event, itemId) => {}",description:"Most in time you will not need to use this return value field. This function is the general function which will be activate for all items when clicked. you can set it directly as the item's element on click callback only if you make sure you pass the item index parameter correctly to the function."}),e.jsx(o,{name:"focusedElementProps",type:"{role, aria-activedescendant}",description:"All the required props which should be defined inside the naturally focused element inside your component according to the accessibility standards"}),e.jsx(o,{name:"setVisualFocusItemId",type:"(visualFocusItemId, isTriggeredByKeyboard) => {}",description:"A function for controlling the visual focused item from outside (needed for cases such as exiting sub menu or dialog, when we want to return the focus to the last focused item."})]})}),`
`,e.jsx(t.h2,{id:"usage",children:"Usage"}),`
`,e.jsx(t.p,{children:"This hook contains the implementation of all the logic needed for managing the focus of a component that fits the following description:"}),`
`,e.jsxs(s,{children:[e.jsx(i,{children:e.jsx(t.p,{children:"The component displays a list of values shown in one dimension - horizontal or vertical."})}),e.jsx(i,{children:e.jsx(t.p,{children:"The user can interact with the component items, and therefore, the component is focusable."})}),e.jsx(i,{children:e.jsx(t.p,{children:`When the user focuses on the component, the browser's real focus will always be on an element that is not one of the
component's items. Most of the time, the focus will be on the component's Search item or different Text input item.`})}),e.jsx(i,{children:e.jsx(t.p,{children:`Meanwhile, the user can navigate between items and select one of them by using the keyboard. but the focus on the
list's item is always only visual (the real focus always be on a specific element, as explained before.)`})})]})]})}function be(n={}){const{wrapper:t}={...c(),...n.components};return t?e.jsx(t,{...n,children:e.jsx(a,{...n})}):a(n)}export{be as default};
